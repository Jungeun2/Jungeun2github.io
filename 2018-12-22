▶ 2018.12.22◀ 

▷ Java의 정석 [ Chapter 02 - 변수 ]

저번시간에 상수와 리터럴에 대해 정리해보았다. 이번시간엔 리터럴의 타입과 접미사, 타입의 불일치를 정리할 것이다.

논리형의 리터럴은 false와 true이다.
실수형의 리터럴은 123,0b0101, 077 등이 있고 접미사는 L이다.
실수형의 리터럴은 3.14, 3.0e8, 1.4f 등이 있고 접미사는 f와 d이다.
문자형의 리터럴은 'A', '1', '\n'이다.
문자열의 리터럴은 "ABC", "123", "A", "true"이다.

논리형과 문자형, 문자열은 접미사가 없다.

정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 접미사를 붙여서 타입을 구분한다.
정수형의 경우, long타입의 리터럴에 접미사 'l' 또는 'L'을 붙이고, 접미사가 없으면 int타입의 리터럴이다.
10진수 외에도 2, 8, 16진수로 표현된 리터럴을 변수에 저장할 수 있으며,
16진수라는것을 표시하기 위해 리터럴 앞에 접두사'0x' 또는 '0X'를, 8진수의 경우에는 '0'을 붙인다.

ex) int octNum = 010;   // 8진수 10, 10진수로 8
    int hexNum = 0x10;  // 16진수 10, 10진수로 16
    int binNum = 0b10;  // 2진수 10, 10진수로 2
    
실수형에서는 float타입의 리터럴에 접미사 'f' 또는 'F'를 붙이고, double타입의 리터럴에는 접미사 'd' 또는 'D'를 붙인다.
실수형 리터럴에서느 접미사를 붙여서 타입을 구분하며, float타입 리터럴에는 'f'를, double타입 리터럴에는 'd'를 붙인다.

ex) float pi = 3.14;    // 에러. float타입 변수에 double타입 리터럴 저장불가.
    double rate = 1.618 // OK. 접미사 d는는 생략할 수 있다.
    
리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만,
타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.

ex) int i = 'A';      // OK. 문자 'A'의 유니코드인 65가 변수 i에 저장된다.
    long i = 123;     // OK. int보다 long타입이 더 범위가 넓다.
    double d = 3.14f; // OK. float보다 double타입이 더 범위가 넓다.
    
그러나 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장범위가 넓으면 컴파일 에러가 발생한다.

ex) int i = 0x123456789;    // 에러. int 타입의 범위를 넘는 값을 저장
    float f = 3.14;         // 에러. float 타입보다 double 타입의 범위가 넓다.
    > 3.14sms 3.14d에서 접미사가 생략된 것으로 double타입이다. 이 값을 float타입으로 표현 할 수 있지만,
      double타입의 리터럴이므로 float타입의 변수에 저장할 수는 없다.

byte와 short타입의 리터럴은 따로 존재하지 않으므로 int타입의 리터럴을 사용한다.
단, short타입의 변수가 저장할 수 있는 범위에 속한 것이어야 한다.

ex) byte b = 65;      // OK. byte타입에 저장 가능한 범위의 int타입 리터럴
    short s = 0x1234; // OK. short타입에 젖아 가능한 범위의 int타입 리터럴
    
이렇게 배운내용을 정리해보았다. 이번 내용은 엄청 복잡한것 같아서 한번 정리하고나서 다시 보지 않으면 아예 까먹을 것 같아서
올린글을 다시 찾아보거나 책을 보면서 복습을 해야겠다고 생각을 하였다.
